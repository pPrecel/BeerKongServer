// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	prisma "github.com/pPrecel/BeerKongServer/pkg/prisma/generated/prisma-client"
	"github.com/vektah/gqlparser"
	"github.com/vektah/gqlparser/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	League() LeagueResolver
	Match() MatchResolver
	Mutation() MutationResolver
	Query() QueryResolver
	Team() TeamResolver
	User() UserResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	League struct {
		CreatedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Owner       func(childComplexity int) int
		Teams       func(childComplexity int) int
		Users       func(childComplexity int) int
	}

	Match struct {
		CreatedAt    func(childComplexity int) int
		ID           func(childComplexity int) int
		IsFinished   func(childComplexity int) int
		IsRanked     func(childComplexity int) int
		League       func(childComplexity int) int
		PlannedAt    func(childComplexity int) int
		User1        func(childComplexity int) int
		User1points  func(childComplexity int) int
		User2        func(childComplexity int) int
		User2points  func(childComplexity int) int
		Winner       func(childComplexity int) int
		WinnerPoints func(childComplexity int) int
	}

	Mutation struct {
		AddUserToTeam       func(childComplexity int, where prisma.TeamWhereUniqueInput, data prisma.UserWhereUniqueInput) int
		CreateLeague        func(childComplexity int, data LeagueCreateInput) int
		CreateMatch         func(childComplexity int, data MatchCreateInput) int
		CreateTeam          func(childComplexity int, data TeamCreateInput) int
		DeleteLeague        func(childComplexity int, where prisma.LeagueWhereUniqueInput) int
		DeleteMatch         func(childComplexity int, where prisma.MatchWhereUniqueInput) int
		DeleteTeam          func(childComplexity int, where prisma.TeamWhereUniqueInput) int
		DeleteUser          func(childComplexity int) int
		EndMatch            func(childComplexity int, where prisma.MatchWhereUniqueInput, data MatchEndInput) int
		LoginOrRegisterUser func(childComplexity int, data UserCreateInput) int
	}

	Query struct {
		League  func(childComplexity int, where prisma.LeagueWhereUniqueInput) int
		Leagues func(childComplexity int, where *prisma.LeagueWhereInput, orderBy *prisma.LeagueOrderByInput, skip *int, after *string, before *string, first *int, last *int) int
		Match   func(childComplexity int, where prisma.MatchWhereUniqueInput) int
		Matches func(childComplexity int, where *prisma.MatchWhereInput, orderBy *prisma.MatchOrderByInput, skip *int, after *string, before *string, first *int, last *int) int
		Team    func(childComplexity int, where prisma.TeamWhereUniqueInput) int
		Teams   func(childComplexity int, where *prisma.TeamWhereInput, orderBy *prisma.TeamOrderByInput, skip *int, after *string, before *string, first *int, last *int) int
		User    func(childComplexity int, where prisma.UserWhereUniqueInput) int
		Users   func(childComplexity int, where *prisma.UserWhereInput, orderBy *prisma.UserOrderByInput, skip *int, after *string, before *string, first *int, last *int) int
	}

	Team struct {
		CreatedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		League      func(childComplexity int) int
		Name        func(childComplexity int) int
		Owner       func(childComplexity int) int
		Points      func(childComplexity int) int
		Users       func(childComplexity int) int
	}

	User struct {
		CreatedAt    func(childComplexity int) int
		ID           func(childComplexity int) int
		Leagues      func(childComplexity int) int
		Matches      func(childComplexity int) int
		Name         func(childComplexity int) int
		OwnedLeagues func(childComplexity int) int
		OwnedTeams   func(childComplexity int) int
		Picture      func(childComplexity int) int
		Points       func(childComplexity int) int
		Sub          func(childComplexity int) int
		Teams        func(childComplexity int) int
	}
}

type LeagueResolver interface {
	Teams(ctx context.Context, obj *prisma.League) ([]prisma.Team, error)
	Users(ctx context.Context, obj *prisma.League) ([]prisma.User, error)
	Owner(ctx context.Context, obj *prisma.League) (*prisma.User, error)
}
type MatchResolver interface {
	League(ctx context.Context, obj *prisma.Match) (*prisma.League, error)
	User1(ctx context.Context, obj *prisma.Match) (*prisma.User, error)

	User2(ctx context.Context, obj *prisma.Match) (*prisma.User, error)

	Winner(ctx context.Context, obj *prisma.Match) (*prisma.User, error)
}
type MutationResolver interface {
	CreateLeague(ctx context.Context, data LeagueCreateInput) (*prisma.League, error)
	DeleteLeague(ctx context.Context, where prisma.LeagueWhereUniqueInput) (*prisma.League, error)
	CreateTeam(ctx context.Context, data TeamCreateInput) (*prisma.Team, error)
	DeleteTeam(ctx context.Context, where prisma.TeamWhereUniqueInput) (*prisma.Team, error)
	LoginOrRegisterUser(ctx context.Context, data UserCreateInput) (*prisma.User, error)
	AddUserToTeam(ctx context.Context, where prisma.TeamWhereUniqueInput, data prisma.UserWhereUniqueInput) (*prisma.Team, error)
	DeleteUser(ctx context.Context) (*prisma.User, error)
	CreateMatch(ctx context.Context, data MatchCreateInput) (*prisma.Match, error)
	EndMatch(ctx context.Context, where prisma.MatchWhereUniqueInput, data MatchEndInput) (*prisma.Match, error)
	DeleteMatch(ctx context.Context, where prisma.MatchWhereUniqueInput) (*prisma.Match, error)
}
type QueryResolver interface {
	League(ctx context.Context, where prisma.LeagueWhereUniqueInput) (*prisma.League, error)
	Leagues(ctx context.Context, where *prisma.LeagueWhereInput, orderBy *prisma.LeagueOrderByInput, skip *int, after *string, before *string, first *int, last *int) ([]*prisma.League, error)
	Team(ctx context.Context, where prisma.TeamWhereUniqueInput) (*prisma.Team, error)
	Teams(ctx context.Context, where *prisma.TeamWhereInput, orderBy *prisma.TeamOrderByInput, skip *int, after *string, before *string, first *int, last *int) ([]*prisma.Team, error)
	User(ctx context.Context, where prisma.UserWhereUniqueInput) (*prisma.User, error)
	Users(ctx context.Context, where *prisma.UserWhereInput, orderBy *prisma.UserOrderByInput, skip *int, after *string, before *string, first *int, last *int) ([]*prisma.User, error)
	Match(ctx context.Context, where prisma.MatchWhereUniqueInput) (*prisma.Match, error)
	Matches(ctx context.Context, where *prisma.MatchWhereInput, orderBy *prisma.MatchOrderByInput, skip *int, after *string, before *string, first *int, last *int) ([]*prisma.Match, error)
}
type TeamResolver interface {
	League(ctx context.Context, obj *prisma.Team) (*prisma.League, error)

	Users(ctx context.Context, obj *prisma.Team) ([]prisma.User, error)
	Owner(ctx context.Context, obj *prisma.Team) (*prisma.User, error)
}
type UserResolver interface {
	Teams(ctx context.Context, obj *prisma.User) ([]prisma.Team, error)
	Leagues(ctx context.Context, obj *prisma.User) ([]prisma.League, error)

	OwnedTeams(ctx context.Context, obj *prisma.User) ([]prisma.Team, error)
	OwnedLeagues(ctx context.Context, obj *prisma.User) ([]prisma.League, error)
	Matches(ctx context.Context, obj *prisma.User) ([]prisma.Match, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "League.createdAt":
		if e.complexity.League.CreatedAt == nil {
			break
		}

		return e.complexity.League.CreatedAt(childComplexity), true

	case "League.description":
		if e.complexity.League.Description == nil {
			break
		}

		return e.complexity.League.Description(childComplexity), true

	case "League.id":
		if e.complexity.League.ID == nil {
			break
		}

		return e.complexity.League.ID(childComplexity), true

	case "League.name":
		if e.complexity.League.Name == nil {
			break
		}

		return e.complexity.League.Name(childComplexity), true

	case "League.owner":
		if e.complexity.League.Owner == nil {
			break
		}

		return e.complexity.League.Owner(childComplexity), true

	case "League.teams":
		if e.complexity.League.Teams == nil {
			break
		}

		return e.complexity.League.Teams(childComplexity), true

	case "League.users":
		if e.complexity.League.Users == nil {
			break
		}

		return e.complexity.League.Users(childComplexity), true

	case "Match.createdAt":
		if e.complexity.Match.CreatedAt == nil {
			break
		}

		return e.complexity.Match.CreatedAt(childComplexity), true

	case "Match.id":
		if e.complexity.Match.ID == nil {
			break
		}

		return e.complexity.Match.ID(childComplexity), true

	case "Match.isFinished":
		if e.complexity.Match.IsFinished == nil {
			break
		}

		return e.complexity.Match.IsFinished(childComplexity), true

	case "Match.isRanked":
		if e.complexity.Match.IsRanked == nil {
			break
		}

		return e.complexity.Match.IsRanked(childComplexity), true

	case "Match.league":
		if e.complexity.Match.League == nil {
			break
		}

		return e.complexity.Match.League(childComplexity), true

	case "Match.plannedAt":
		if e.complexity.Match.PlannedAt == nil {
			break
		}

		return e.complexity.Match.PlannedAt(childComplexity), true

	case "Match.user1":
		if e.complexity.Match.User1 == nil {
			break
		}

		return e.complexity.Match.User1(childComplexity), true

	case "Match.user1points":
		if e.complexity.Match.User1points == nil {
			break
		}

		return e.complexity.Match.User1points(childComplexity), true

	case "Match.user2":
		if e.complexity.Match.User2 == nil {
			break
		}

		return e.complexity.Match.User2(childComplexity), true

	case "Match.user2points":
		if e.complexity.Match.User2points == nil {
			break
		}

		return e.complexity.Match.User2points(childComplexity), true

	case "Match.winner":
		if e.complexity.Match.Winner == nil {
			break
		}

		return e.complexity.Match.Winner(childComplexity), true

	case "Match.winnerPoints":
		if e.complexity.Match.WinnerPoints == nil {
			break
		}

		return e.complexity.Match.WinnerPoints(childComplexity), true

	case "Mutation.addUserToTeam":
		if e.complexity.Mutation.AddUserToTeam == nil {
			break
		}

		args, err := ec.field_Mutation_addUserToTeam_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddUserToTeam(childComplexity, args["where"].(prisma.TeamWhereUniqueInput), args["data"].(prisma.UserWhereUniqueInput)), true

	case "Mutation.createLeague":
		if e.complexity.Mutation.CreateLeague == nil {
			break
		}

		args, err := ec.field_Mutation_createLeague_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateLeague(childComplexity, args["data"].(LeagueCreateInput)), true

	case "Mutation.createMatch":
		if e.complexity.Mutation.CreateMatch == nil {
			break
		}

		args, err := ec.field_Mutation_createMatch_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMatch(childComplexity, args["data"].(MatchCreateInput)), true

	case "Mutation.createTeam":
		if e.complexity.Mutation.CreateTeam == nil {
			break
		}

		args, err := ec.field_Mutation_createTeam_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTeam(childComplexity, args["data"].(TeamCreateInput)), true

	case "Mutation.deleteLeague":
		if e.complexity.Mutation.DeleteLeague == nil {
			break
		}

		args, err := ec.field_Mutation_deleteLeague_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteLeague(childComplexity, args["where"].(prisma.LeagueWhereUniqueInput)), true

	case "Mutation.deleteMatch":
		if e.complexity.Mutation.DeleteMatch == nil {
			break
		}

		args, err := ec.field_Mutation_deleteMatch_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteMatch(childComplexity, args["where"].(prisma.MatchWhereUniqueInput)), true

	case "Mutation.deleteTeam":
		if e.complexity.Mutation.DeleteTeam == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTeam_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTeam(childComplexity, args["where"].(prisma.TeamWhereUniqueInput)), true

	case "Mutation.deleteUser":
		if e.complexity.Mutation.DeleteUser == nil {
			break
		}

		return e.complexity.Mutation.DeleteUser(childComplexity), true

	case "Mutation.endMatch":
		if e.complexity.Mutation.EndMatch == nil {
			break
		}

		args, err := ec.field_Mutation_endMatch_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EndMatch(childComplexity, args["where"].(prisma.MatchWhereUniqueInput), args["data"].(MatchEndInput)), true

	case "Mutation.loginOrRegisterUser":
		if e.complexity.Mutation.LoginOrRegisterUser == nil {
			break
		}

		args, err := ec.field_Mutation_loginOrRegisterUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.LoginOrRegisterUser(childComplexity, args["data"].(UserCreateInput)), true

	case "Query.league":
		if e.complexity.Query.League == nil {
			break
		}

		args, err := ec.field_Query_league_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.League(childComplexity, args["where"].(prisma.LeagueWhereUniqueInput)), true

	case "Query.leagues":
		if e.complexity.Query.Leagues == nil {
			break
		}

		args, err := ec.field_Query_leagues_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Leagues(childComplexity, args["where"].(*prisma.LeagueWhereInput), args["orderBy"].(*prisma.LeagueOrderByInput), args["skip"].(*int), args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Query.match":
		if e.complexity.Query.Match == nil {
			break
		}

		args, err := ec.field_Query_match_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Match(childComplexity, args["where"].(prisma.MatchWhereUniqueInput)), true

	case "Query.matches":
		if e.complexity.Query.Matches == nil {
			break
		}

		args, err := ec.field_Query_matches_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Matches(childComplexity, args["where"].(*prisma.MatchWhereInput), args["orderBy"].(*prisma.MatchOrderByInput), args["skip"].(*int), args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Query.team":
		if e.complexity.Query.Team == nil {
			break
		}

		args, err := ec.field_Query_team_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Team(childComplexity, args["where"].(prisma.TeamWhereUniqueInput)), true

	case "Query.teams":
		if e.complexity.Query.Teams == nil {
			break
		}

		args, err := ec.field_Query_teams_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Teams(childComplexity, args["where"].(*prisma.TeamWhereInput), args["orderBy"].(*prisma.TeamOrderByInput), args["skip"].(*int), args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Query.user":
		if e.complexity.Query.User == nil {
			break
		}

		args, err := ec.field_Query_user_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.User(childComplexity, args["where"].(prisma.UserWhereUniqueInput)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		args, err := ec.field_Query_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Users(childComplexity, args["where"].(*prisma.UserWhereInput), args["orderBy"].(*prisma.UserOrderByInput), args["skip"].(*int), args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Team.createdAt":
		if e.complexity.Team.CreatedAt == nil {
			break
		}

		return e.complexity.Team.CreatedAt(childComplexity), true

	case "Team.description":
		if e.complexity.Team.Description == nil {
			break
		}

		return e.complexity.Team.Description(childComplexity), true

	case "Team.id":
		if e.complexity.Team.ID == nil {
			break
		}

		return e.complexity.Team.ID(childComplexity), true

	case "Team.league":
		if e.complexity.Team.League == nil {
			break
		}

		return e.complexity.Team.League(childComplexity), true

	case "Team.name":
		if e.complexity.Team.Name == nil {
			break
		}

		return e.complexity.Team.Name(childComplexity), true

	case "Team.owner":
		if e.complexity.Team.Owner == nil {
			break
		}

		return e.complexity.Team.Owner(childComplexity), true

	case "Team.points":
		if e.complexity.Team.Points == nil {
			break
		}

		return e.complexity.Team.Points(childComplexity), true

	case "Team.users":
		if e.complexity.Team.Users == nil {
			break
		}

		return e.complexity.Team.Users(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.leagues":
		if e.complexity.User.Leagues == nil {
			break
		}

		return e.complexity.User.Leagues(childComplexity), true

	case "User.matches":
		if e.complexity.User.Matches == nil {
			break
		}

		return e.complexity.User.Matches(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.ownedLeagues":
		if e.complexity.User.OwnedLeagues == nil {
			break
		}

		return e.complexity.User.OwnedLeagues(childComplexity), true

	case "User.ownedTeams":
		if e.complexity.User.OwnedTeams == nil {
			break
		}

		return e.complexity.User.OwnedTeams(childComplexity), true

	case "User.picture":
		if e.complexity.User.Picture == nil {
			break
		}

		return e.complexity.User.Picture(childComplexity), true

	case "User.points":
		if e.complexity.User.Points == nil {
			break
		}

		return e.complexity.User.Points(childComplexity), true

	case "User.sub":
		if e.complexity.User.Sub == nil {
			break
		}

		return e.complexity.User.Sub(childComplexity), true

	case "User.teams":
		if e.complexity.User.Teams == nil {
			break
		}

		return e.complexity.User.Teams(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Mutation(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Mutation(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Subscription(ctx context.Context, op *ast.OperationDefinition) func() *graphql.Response {
	return graphql.OneShot(graphql.ErrorResponse(ctx, "subscriptions are not supported"))
}

type executionContext struct {
	*graphql.RequestContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var parsedSchema = gqlparser.MustLoadSchema(
	&ast.Source{Name: "scheme/mutation.graphql", Input: `type Mutation {
  createLeague(data: LeagueCreateInput!): League!
  deleteLeague(where: LeagueWhereUniqueInput!): League
  createTeam(data: TeamCreateInput!): Team!
  deleteTeam(where: TeamWhereUniqueInput!): Team
  loginOrRegisterUser(data: UserCreateInput!): User!
  addUserToTeam(where: TeamWhereUniqueInput!, data: UserWhereUniqueInput!): Team!
  deleteUser: User
  createMatch(data: MatchCreateInput!): Match!
  endMatch(where: MatchWhereUniqueInput!, data: MatchEndInput!):Match!
  deleteMatch(where: MatchWhereUniqueInput!): Match
}

input LeagueCreateInput {
  description: String!
  name: String!
  users: [UserWhereUniqueInput!]
}

input TeamCreateInput {
  id: ID
  description: String!
  name: String!
  league: LeagueWhereUniqueInput!
}

input UserCreateInput {
  id: ID
  name: String!
  sub: String!
  picture: String!
}

input MatchCreateInput {
  plannedAt: DateTime!
  isRanked: Boolean!
  league: LeagueWhereUniqueInput!
  user1: UserWhereUniqueInput!
  user2: UserWhereUniqueInput!
}

input MatchEndInput {
  user1points: Int!
  user2points: Int!
}
`},
	&ast.Source{Name: "scheme/query.graphql", Input: `type Query {
  league(where: LeagueWhereUniqueInput!): League
  leagues(where: LeagueWhereInput, orderBy: LeagueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [League]!
  team(where: TeamWhereUniqueInput!): Team
  teams(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Team]!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  match(where: MatchWhereUniqueInput!): Match
  matches(where: MatchWhereInput, orderBy: MatchOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Match]!
}

scalar DateTime

enum LeagueOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  description_ASC
  description_DESC
  name_ASC
  name_DESC
}

enum TeamOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  description_ASC
  description_DESC
  name_ASC
  name_DESC
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  name_ASC
  name_DESC
  sub_ASC
  sub_DESC
  picture_ASC
  picture_DESC
  points_ASC
  points_DESC
}

enum MatchOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  plannedAt_ASC
  plannedAt_DESC
  isRanked_ASC
  isRanked_DESC
  isFinished_ASC
  isFinished_DESC
  user1points_ASC
  user1points_DESC
  user2points_ASC
  user2points_DESC
  winnerPoints_ASC
  winnerPoints_DESC
}

input LeagueWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  teams_every: TeamWhereInput
  teams_some: TeamWhereInput
  teams_none: TeamWhereInput
  users_every: UserWhereInput
  users_some: UserWhereInput
  users_none: UserWhereInput
  owner: UserWhereInput
  AND: [LeagueWhereInput!]
  OR: [LeagueWhereInput!]
  NOT: [LeagueWhereInput!]
}

input TeamWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  league: LeagueWhereInput
  users_every: UserWhereInput
  users_some: UserWhereInput
  users_none: UserWhereInput
  owner: UserWhereInput
  AND: [TeamWhereInput!]
  OR: [TeamWhereInput!]
  NOT: [TeamWhereInput!]
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  sub: String
  sub_not: String
  sub_in: [String!]
  sub_not_in: [String!]
  sub_lt: String
  sub_lte: String
  sub_gt: String
  sub_gte: String
  sub_contains: String
  sub_not_contains: String
  sub_starts_with: String
  sub_not_starts_with: String
  sub_ends_with: String
  sub_not_ends_with: String
  picture: String
  picture_not: String
  picture_in: [String!]
  picture_not_in: [String!]
  picture_lt: String
  picture_lte: String
  picture_gt: String
  picture_gte: String
  picture_contains: String
  picture_not_contains: String
  picture_starts_with: String
  picture_not_starts_with: String
  picture_ends_with: String
  picture_not_ends_with: String
  points: Int
  points_not: Int
  points_in: [Int!]
  points_not_in: [Int!]
  points_lt: Int
  points_lte: Int
  points_gt: Int
  points_gte: Int
  teams_every: TeamWhereInput
  teams_some: TeamWhereInput
  teams_none: TeamWhereInput
  leagues_every: LeagueWhereInput
  leagues_some: LeagueWhereInput
  leagues_none: LeagueWhereInput
  ownedTeams_every: TeamWhereInput
  ownedTeams_some: TeamWhereInput
  ownedTeams_none: TeamWhereInput
  ownedLeagues_every: LeagueWhereInput
  ownedLeagues_some: LeagueWhereInput
  ownedLeagues_none: LeagueWhereInput
  matches_every: MatchWhereInput
  matches_some: MatchWhereInput
  matches_none: MatchWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input MatchWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  plannedAt: DateTime
  plannedAt_not: DateTime
  plannedAt_in: [DateTime!]
  plannedAt_not_in: [DateTime!]
  plannedAt_lt: DateTime
  plannedAt_lte: DateTime
  plannedAt_gt: DateTime
  plannedAt_gte: DateTime
  isRanked: Boolean
  isRanked_not: Boolean
  isFinished: Boolean
  isFinished_not: Boolean
  league: LeagueWhereInput
  user1: UserWhereInput
  user1points: Int
  user1points_not: Int
  user1points_in: [Int!]
  user1points_not_in: [Int!]
  user1points_lt: Int
  user1points_lte: Int
  user1points_gt: Int
  user1points_gte: Int
  user2: UserWhereInput
  user2points: Int
  user2points_not: Int
  user2points_in: [Int!]
  user2points_not_in: [Int!]
  user2points_lt: Int
  user2points_lte: Int
  user2points_gt: Int
  user2points_gte: Int
  winner: UserWhereInput
  winnerPoints: Int
  winnerPoints_not: Int
  winnerPoints_in: [Int!]
  winnerPoints_not_in: [Int!]
  winnerPoints_lt: Int
  winnerPoints_lte: Int
  winnerPoints_gt: Int
  winnerPoints_gte: Int
  AND: [MatchWhereInput!]
  OR: [MatchWhereInput!]
  NOT: [MatchWhereInput!]
}

input LeagueWhereUniqueInput {
  id: ID
  name: String
}

input TeamWhereUniqueInput {
  id: ID
  name: String
}

input UserWhereUniqueInput {
  id: ID
  name: String
  sub: String
}

input MatchWhereUniqueInput {
  id: ID
}
`},
	&ast.Source{Name: "scheme/types.graphql", Input: `type League {
  id: ID!
  createdAt: DateTime!
  description: String!
  name: String!
  teams: [Team!]
  users: [User!]
  owner: User!
}

type Team {
  id: ID!
  createdAt: DateTime!
  description: String!
  name: String!
  league: League!
  points: Int!
  users: [User!]
  owner: User!
}

type User {
  id: ID!
  createdAt: DateTime!
  name: String!
  sub: String!
  picture: String!
  teams: [Team!]
  leagues: [League!]
  points: Int!
  ownedTeams: [Team!]
  ownedLeagues: [League!]
  matches: [Match!]!
}

type Match {
  id: ID!
  createdAt: DateTime!
  plannedAt: DateTime!
  isRanked: Boolean!
  isFinished: Boolean
  league: League!
  user1: User!
  user1points: Int
  user2: User!
  user2points: Int
  winner: User
  winnerPoints: Int
}`},
)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_addUserToTeam_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 prisma.TeamWhereUniqueInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalNTeamWhereUniqueInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamWhereUniqueInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	var arg1 prisma.UserWhereUniqueInput
	if tmp, ok := rawArgs["data"]; ok {
		arg1, err = ec.unmarshalNUserWhereUniqueInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereUniqueInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createLeague_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 LeagueCreateInput
	if tmp, ok := rawArgs["data"]; ok {
		arg0, err = ec.unmarshalNLeagueCreateInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋgraphqlᚋgeneratedᚐLeagueCreateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createMatch_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 MatchCreateInput
	if tmp, ok := rawArgs["data"]; ok {
		arg0, err = ec.unmarshalNMatchCreateInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋgraphqlᚋgeneratedᚐMatchCreateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createTeam_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 TeamCreateInput
	if tmp, ok := rawArgs["data"]; ok {
		arg0, err = ec.unmarshalNTeamCreateInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋgraphqlᚋgeneratedᚐTeamCreateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteLeague_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 prisma.LeagueWhereUniqueInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalNLeagueWhereUniqueInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueWhereUniqueInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteMatch_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 prisma.MatchWhereUniqueInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalNMatchWhereUniqueInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatchWhereUniqueInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteTeam_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 prisma.TeamWhereUniqueInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalNTeamWhereUniqueInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamWhereUniqueInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_endMatch_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 prisma.MatchWhereUniqueInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalNMatchWhereUniqueInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatchWhereUniqueInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	var arg1 MatchEndInput
	if tmp, ok := rawArgs["data"]; ok {
		arg1, err = ec.unmarshalNMatchEndInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋgraphqlᚋgeneratedᚐMatchEndInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_loginOrRegisterUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 UserCreateInput
	if tmp, ok := rawArgs["data"]; ok {
		arg0, err = ec.unmarshalNUserCreateInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋgraphqlᚋgeneratedᚐUserCreateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_league_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 prisma.LeagueWhereUniqueInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalNLeagueWhereUniqueInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueWhereUniqueInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_leagues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *prisma.LeagueWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOLeagueWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	var arg1 *prisma.LeagueOrderByInput
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg1, err = ec.unmarshalOLeagueOrderByInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueOrderByInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["skip"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["skip"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["after"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["before"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg4
	var arg5 *int
	if tmp, ok := rawArgs["first"]; ok {
		arg5, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg5
	var arg6 *int
	if tmp, ok := rawArgs["last"]; ok {
		arg6, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg6
	return args, nil
}

func (ec *executionContext) field_Query_match_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 prisma.MatchWhereUniqueInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalNMatchWhereUniqueInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatchWhereUniqueInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_matches_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *prisma.MatchWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOMatchWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatchWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	var arg1 *prisma.MatchOrderByInput
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg1, err = ec.unmarshalOMatchOrderByInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatchOrderByInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["skip"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["skip"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["after"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["before"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg4
	var arg5 *int
	if tmp, ok := rawArgs["first"]; ok {
		arg5, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg5
	var arg6 *int
	if tmp, ok := rawArgs["last"]; ok {
		arg6, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg6
	return args, nil
}

func (ec *executionContext) field_Query_team_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 prisma.TeamWhereUniqueInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalNTeamWhereUniqueInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamWhereUniqueInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_teams_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *prisma.TeamWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOTeamWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	var arg1 *prisma.TeamOrderByInput
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg1, err = ec.unmarshalOTeamOrderByInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamOrderByInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["skip"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["skip"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["after"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["before"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg4
	var arg5 *int
	if tmp, ok := rawArgs["first"]; ok {
		arg5, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg5
	var arg6 *int
	if tmp, ok := rawArgs["last"]; ok {
		arg6, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg6
	return args, nil
}

func (ec *executionContext) field_Query_user_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 prisma.UserWhereUniqueInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalNUserWhereUniqueInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereUniqueInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_users_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *prisma.UserWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOUserWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	var arg1 *prisma.UserOrderByInput
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg1, err = ec.unmarshalOUserOrderByInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserOrderByInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["skip"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["skip"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["after"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["before"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg4
	var arg5 *int
	if tmp, ok := rawArgs["first"]; ok {
		arg5, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg5
	var arg6 *int
	if tmp, ok := rawArgs["last"]; ok {
		arg6, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg6
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _League_id(ctx context.Context, field graphql.CollectedField, obj *prisma.League) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "League",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _League_createdAt(ctx context.Context, field graphql.CollectedField, obj *prisma.League) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "League",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _League_description(ctx context.Context, field graphql.CollectedField, obj *prisma.League) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "League",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _League_name(ctx context.Context, field graphql.CollectedField, obj *prisma.League) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "League",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _League_teams(ctx context.Context, field graphql.CollectedField, obj *prisma.League) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "League",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.League().Teams(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]prisma.Team)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTeam2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) _League_users(ctx context.Context, field graphql.CollectedField, obj *prisma.League) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "League",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.League().Users(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]prisma.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUser2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _League_owner(ctx context.Context, field graphql.CollectedField, obj *prisma.League) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "League",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.League().Owner(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*prisma.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_id(ctx context.Context, field graphql.CollectedField, obj *prisma.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_createdAt(ctx context.Context, field graphql.CollectedField, obj *prisma.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_plannedAt(ctx context.Context, field graphql.CollectedField, obj *prisma.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlannedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_isRanked(ctx context.Context, field graphql.CollectedField, obj *prisma.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRanked, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_isFinished(ctx context.Context, field graphql.CollectedField, obj *prisma.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsFinished, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_league(ctx context.Context, field graphql.CollectedField, obj *prisma.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Match().League(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*prisma.League)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNLeague2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeague(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_user1(ctx context.Context, field graphql.CollectedField, obj *prisma.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Match().User1(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*prisma.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_user1points(ctx context.Context, field graphql.CollectedField, obj *prisma.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User1points, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int32)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_user2(ctx context.Context, field graphql.CollectedField, obj *prisma.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Match().User2(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*prisma.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_user2points(ctx context.Context, field graphql.CollectedField, obj *prisma.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User2points, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int32)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_winner(ctx context.Context, field graphql.CollectedField, obj *prisma.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Match().Winner(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*prisma.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUser2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_winnerPoints(ctx context.Context, field graphql.CollectedField, obj *prisma.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WinnerPoints, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int32)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createLeague(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createLeague_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateLeague(rctx, args["data"].(LeagueCreateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*prisma.League)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNLeague2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeague(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteLeague(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteLeague_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteLeague(rctx, args["where"].(prisma.LeagueWhereUniqueInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*prisma.League)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOLeague2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeague(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createTeam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createTeam_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateTeam(rctx, args["data"].(TeamCreateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*prisma.Team)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTeam2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteTeam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteTeam_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteTeam(rctx, args["where"].(prisma.TeamWhereUniqueInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*prisma.Team)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTeam2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_loginOrRegisterUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_loginOrRegisterUser_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().LoginOrRegisterUser(rctx, args["data"].(UserCreateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*prisma.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_addUserToTeam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_addUserToTeam_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddUserToTeam(rctx, args["where"].(prisma.TeamWhereUniqueInput), args["data"].(prisma.UserWhereUniqueInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*prisma.Team)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTeam2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteUser(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*prisma.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUser2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createMatch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createMatch_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateMatch(rctx, args["data"].(MatchCreateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*prisma.Match)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMatch2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatch(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_endMatch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_endMatch_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().EndMatch(rctx, args["where"].(prisma.MatchWhereUniqueInput), args["data"].(MatchEndInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*prisma.Match)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMatch2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatch(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteMatch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteMatch_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteMatch(rctx, args["where"].(prisma.MatchWhereUniqueInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*prisma.Match)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOMatch2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatch(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_league(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_league_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().League(rctx, args["where"].(prisma.LeagueWhereUniqueInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*prisma.League)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOLeague2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeague(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_leagues(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_leagues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Leagues(rctx, args["where"].(*prisma.LeagueWhereInput), args["orderBy"].(*prisma.LeagueOrderByInput), args["skip"].(*int), args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*prisma.League)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNLeague2ᚕᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeague(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_team(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_team_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Team(rctx, args["where"].(prisma.TeamWhereUniqueInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*prisma.Team)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTeam2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_teams(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_teams_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Teams(rctx, args["where"].(*prisma.TeamWhereInput), args["orderBy"].(*prisma.TeamOrderByInput), args["skip"].(*int), args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*prisma.Team)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTeam2ᚕᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_user(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_user_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().User(rctx, args["where"].(prisma.UserWhereUniqueInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*prisma.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUser2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_users(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_users_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Users(rctx, args["where"].(*prisma.UserWhereInput), args["orderBy"].(*prisma.UserOrderByInput), args["skip"].(*int), args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*prisma.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚕᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_match(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_match_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Match(rctx, args["where"].(prisma.MatchWhereUniqueInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*prisma.Match)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOMatch2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatch(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_matches(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_matches_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Matches(rctx, args["where"].(*prisma.MatchWhereInput), args["orderBy"].(*prisma.MatchOrderByInput), args["skip"].(*int), args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*prisma.Match)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMatch2ᚕᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatch(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _Team_id(ctx context.Context, field graphql.CollectedField, obj *prisma.Team) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Team",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Team_createdAt(ctx context.Context, field graphql.CollectedField, obj *prisma.Team) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Team",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Team_description(ctx context.Context, field graphql.CollectedField, obj *prisma.Team) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Team",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Team_name(ctx context.Context, field graphql.CollectedField, obj *prisma.Team) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Team",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Team_league(ctx context.Context, field graphql.CollectedField, obj *prisma.Team) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Team",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().League(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*prisma.League)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNLeague2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeague(ctx, field.Selections, res)
}

func (ec *executionContext) _Team_points(ctx context.Context, field graphql.CollectedField, obj *prisma.Team) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Team",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Points, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) _Team_users(ctx context.Context, field graphql.CollectedField, obj *prisma.Team) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Team",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().Users(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]prisma.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUser2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Team_owner(ctx context.Context, field graphql.CollectedField, obj *prisma.Team) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Team",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().Owner(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*prisma.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *prisma.User) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_createdAt(ctx context.Context, field graphql.CollectedField, obj *prisma.User) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *prisma.User) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_sub(ctx context.Context, field graphql.CollectedField, obj *prisma.User) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sub, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_picture(ctx context.Context, field graphql.CollectedField, obj *prisma.User) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Picture, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_teams(ctx context.Context, field graphql.CollectedField, obj *prisma.User) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Teams(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]prisma.Team)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTeam2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) _User_leagues(ctx context.Context, field graphql.CollectedField, obj *prisma.User) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Leagues(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]prisma.League)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOLeague2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeague(ctx, field.Selections, res)
}

func (ec *executionContext) _User_points(ctx context.Context, field graphql.CollectedField, obj *prisma.User) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Points, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) _User_ownedTeams(ctx context.Context, field graphql.CollectedField, obj *prisma.User) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().OwnedTeams(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]prisma.Team)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTeam2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) _User_ownedLeagues(ctx context.Context, field graphql.CollectedField, obj *prisma.User) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().OwnedLeagues(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]prisma.League)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOLeague2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeague(ctx, field.Selections, res)
}

func (ec *executionContext) _User_matches(ctx context.Context, field graphql.CollectedField, obj *prisma.User) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Matches(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]prisma.Match)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMatch2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatch(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__DirectiveLocation2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputLeagueCreateInput(ctx context.Context, obj interface{}) (LeagueCreateInput, error) {
	var it LeagueCreateInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "description":
			var err error
			it.Description, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "users":
			var err error
			it.Users, err = ec.unmarshalOUserWhereUniqueInput2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereUniqueInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLeagueWhereInput(ctx context.Context, obj interface{}) (prisma.LeagueWhereInput, error) {
	var it prisma.LeagueWhereInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not":
			var err error
			it.IDNot, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_in":
			var err error
			it.IDIn, err = ec.unmarshalOID2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_in":
			var err error
			it.IDNotIn, err = ec.unmarshalOID2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lt":
			var err error
			it.IDLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lte":
			var err error
			it.IDLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gt":
			var err error
			it.IDGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gte":
			var err error
			it.IDGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_contains":
			var err error
			it.IDContains, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_contains":
			var err error
			it.IDNotContains, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_starts_with":
			var err error
			it.IDStartsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_starts_with":
			var err error
			it.IDNotStartsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_ends_with":
			var err error
			it.IDEndsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_ends_with":
			var err error
			it.IDNotEndsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error
			it.CreatedAt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_not":
			var err error
			it.CreatedAtNot, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_in":
			var err error
			it.CreatedAtIn, err = ec.unmarshalODateTime2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_not_in":
			var err error
			it.CreatedAtNotIn, err = ec.unmarshalODateTime2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_lt":
			var err error
			it.CreatedAtLt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_lte":
			var err error
			it.CreatedAtLte, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_gt":
			var err error
			it.CreatedAtGt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_gte":
			var err error
			it.CreatedAtGte, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not":
			var err error
			it.DescriptionNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_in":
			var err error
			it.DescriptionIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not_in":
			var err error
			it.DescriptionNotIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_lt":
			var err error
			it.DescriptionLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_lte":
			var err error
			it.DescriptionLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_gt":
			var err error
			it.DescriptionGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_gte":
			var err error
			it.DescriptionGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_contains":
			var err error
			it.DescriptionContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not_contains":
			var err error
			it.DescriptionNotContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_starts_with":
			var err error
			it.DescriptionStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not_starts_with":
			var err error
			it.DescriptionNotStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_ends_with":
			var err error
			it.DescriptionEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not_ends_with":
			var err error
			it.DescriptionNotEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not":
			var err error
			it.NameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_in":
			var err error
			it.NameIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_in":
			var err error
			it.NameNotIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_lt":
			var err error
			it.NameLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_lte":
			var err error
			it.NameLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_gt":
			var err error
			it.NameGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_gte":
			var err error
			it.NameGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_contains":
			var err error
			it.NameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_contains":
			var err error
			it.NameNotContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_starts_with":
			var err error
			it.NameStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_starts_with":
			var err error
			it.NameNotStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_ends_with":
			var err error
			it.NameEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_ends_with":
			var err error
			it.NameNotEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "teams_every":
			var err error
			it.TeamsEvery, err = ec.unmarshalOTeamWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "teams_some":
			var err error
			it.TeamsSome, err = ec.unmarshalOTeamWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "teams_none":
			var err error
			it.TeamsNone, err = ec.unmarshalOTeamWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "users_every":
			var err error
			it.UsersEvery, err = ec.unmarshalOUserWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "users_some":
			var err error
			it.UsersSome, err = ec.unmarshalOUserWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "users_none":
			var err error
			it.UsersNone, err = ec.unmarshalOUserWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "owner":
			var err error
			it.Owner, err = ec.unmarshalOUserWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOLeagueWhereInput2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOLeagueWhereInput2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOLeagueWhereInput2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLeagueWhereUniqueInput(ctx context.Context, obj interface{}) (prisma.LeagueWhereUniqueInput, error) {
	var it prisma.LeagueWhereUniqueInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMatchCreateInput(ctx context.Context, obj interface{}) (MatchCreateInput, error) {
	var it MatchCreateInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "plannedAt":
			var err error
			it.PlannedAt, err = ec.unmarshalNDateTime2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isRanked":
			var err error
			it.IsRanked, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "league":
			var err error
			it.League, err = ec.unmarshalNLeagueWhereUniqueInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueWhereUniqueInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "user1":
			var err error
			it.User1, err = ec.unmarshalNUserWhereUniqueInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereUniqueInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "user2":
			var err error
			it.User2, err = ec.unmarshalNUserWhereUniqueInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereUniqueInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMatchEndInput(ctx context.Context, obj interface{}) (MatchEndInput, error) {
	var it MatchEndInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "user1points":
			var err error
			it.User1points, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "user2points":
			var err error
			it.User2points, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMatchWhereInput(ctx context.Context, obj interface{}) (prisma.MatchWhereInput, error) {
	var it prisma.MatchWhereInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not":
			var err error
			it.IDNot, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_in":
			var err error
			it.IDIn, err = ec.unmarshalOID2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_in":
			var err error
			it.IDNotIn, err = ec.unmarshalOID2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lt":
			var err error
			it.IDLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lte":
			var err error
			it.IDLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gt":
			var err error
			it.IDGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gte":
			var err error
			it.IDGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_contains":
			var err error
			it.IDContains, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_contains":
			var err error
			it.IDNotContains, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_starts_with":
			var err error
			it.IDStartsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_starts_with":
			var err error
			it.IDNotStartsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_ends_with":
			var err error
			it.IDEndsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_ends_with":
			var err error
			it.IDNotEndsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error
			it.CreatedAt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_not":
			var err error
			it.CreatedAtNot, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_in":
			var err error
			it.CreatedAtIn, err = ec.unmarshalODateTime2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_not_in":
			var err error
			it.CreatedAtNotIn, err = ec.unmarshalODateTime2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_lt":
			var err error
			it.CreatedAtLt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_lte":
			var err error
			it.CreatedAtLte, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_gt":
			var err error
			it.CreatedAtGt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_gte":
			var err error
			it.CreatedAtGte, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "plannedAt":
			var err error
			it.PlannedAt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "plannedAt_not":
			var err error
			it.PlannedAtNot, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "plannedAt_in":
			var err error
			it.PlannedAtIn, err = ec.unmarshalODateTime2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "plannedAt_not_in":
			var err error
			it.PlannedAtNotIn, err = ec.unmarshalODateTime2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "plannedAt_lt":
			var err error
			it.PlannedAtLt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "plannedAt_lte":
			var err error
			it.PlannedAtLte, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "plannedAt_gt":
			var err error
			it.PlannedAtGt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "plannedAt_gte":
			var err error
			it.PlannedAtGte, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "isRanked":
			var err error
			it.IsRanked, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isRanked_not":
			var err error
			it.IsRankedNot, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isFinished":
			var err error
			it.IsFinished, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isFinished_not":
			var err error
			it.IsFinishedNot, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "league":
			var err error
			it.League, err = ec.unmarshalOLeagueWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "user1":
			var err error
			it.User1, err = ec.unmarshalOUserWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "user1points":
			var err error
			it.User1points, err = ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "user1points_not":
			var err error
			it.User1pointsNot, err = ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "user1points_in":
			var err error
			it.User1pointsIn, err = ec.unmarshalOInt2ᚕint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "user1points_not_in":
			var err error
			it.User1pointsNotIn, err = ec.unmarshalOInt2ᚕint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "user1points_lt":
			var err error
			it.User1pointsLt, err = ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "user1points_lte":
			var err error
			it.User1pointsLte, err = ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "user1points_gt":
			var err error
			it.User1pointsGt, err = ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "user1points_gte":
			var err error
			it.User1pointsGte, err = ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "user2":
			var err error
			it.User2, err = ec.unmarshalOUserWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "user2points":
			var err error
			it.User2points, err = ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "user2points_not":
			var err error
			it.User2pointsNot, err = ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "user2points_in":
			var err error
			it.User2pointsIn, err = ec.unmarshalOInt2ᚕint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "user2points_not_in":
			var err error
			it.User2pointsNotIn, err = ec.unmarshalOInt2ᚕint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "user2points_lt":
			var err error
			it.User2pointsLt, err = ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "user2points_lte":
			var err error
			it.User2pointsLte, err = ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "user2points_gt":
			var err error
			it.User2pointsGt, err = ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "user2points_gte":
			var err error
			it.User2pointsGte, err = ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "winner":
			var err error
			it.Winner, err = ec.unmarshalOUserWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "winnerPoints":
			var err error
			it.WinnerPoints, err = ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "winnerPoints_not":
			var err error
			it.WinnerPointsNot, err = ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "winnerPoints_in":
			var err error
			it.WinnerPointsIn, err = ec.unmarshalOInt2ᚕint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "winnerPoints_not_in":
			var err error
			it.WinnerPointsNotIn, err = ec.unmarshalOInt2ᚕint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "winnerPoints_lt":
			var err error
			it.WinnerPointsLt, err = ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "winnerPoints_lte":
			var err error
			it.WinnerPointsLte, err = ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "winnerPoints_gt":
			var err error
			it.WinnerPointsGt, err = ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "winnerPoints_gte":
			var err error
			it.WinnerPointsGte, err = ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOMatchWhereInput2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatchWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOMatchWhereInput2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatchWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOMatchWhereInput2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatchWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMatchWhereUniqueInput(ctx context.Context, obj interface{}) (prisma.MatchWhereUniqueInput, error) {
	var it prisma.MatchWhereUniqueInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTeamCreateInput(ctx context.Context, obj interface{}) (TeamCreateInput, error) {
	var it TeamCreateInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "league":
			var err error
			it.League, err = ec.unmarshalNLeagueWhereUniqueInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueWhereUniqueInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTeamWhereInput(ctx context.Context, obj interface{}) (prisma.TeamWhereInput, error) {
	var it prisma.TeamWhereInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not":
			var err error
			it.IDNot, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_in":
			var err error
			it.IDIn, err = ec.unmarshalOID2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_in":
			var err error
			it.IDNotIn, err = ec.unmarshalOID2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lt":
			var err error
			it.IDLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lte":
			var err error
			it.IDLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gt":
			var err error
			it.IDGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gte":
			var err error
			it.IDGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_contains":
			var err error
			it.IDContains, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_contains":
			var err error
			it.IDNotContains, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_starts_with":
			var err error
			it.IDStartsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_starts_with":
			var err error
			it.IDNotStartsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_ends_with":
			var err error
			it.IDEndsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_ends_with":
			var err error
			it.IDNotEndsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error
			it.CreatedAt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_not":
			var err error
			it.CreatedAtNot, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_in":
			var err error
			it.CreatedAtIn, err = ec.unmarshalODateTime2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_not_in":
			var err error
			it.CreatedAtNotIn, err = ec.unmarshalODateTime2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_lt":
			var err error
			it.CreatedAtLt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_lte":
			var err error
			it.CreatedAtLte, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_gt":
			var err error
			it.CreatedAtGt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_gte":
			var err error
			it.CreatedAtGte, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not":
			var err error
			it.DescriptionNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_in":
			var err error
			it.DescriptionIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not_in":
			var err error
			it.DescriptionNotIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_lt":
			var err error
			it.DescriptionLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_lte":
			var err error
			it.DescriptionLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_gt":
			var err error
			it.DescriptionGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_gte":
			var err error
			it.DescriptionGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_contains":
			var err error
			it.DescriptionContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not_contains":
			var err error
			it.DescriptionNotContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_starts_with":
			var err error
			it.DescriptionStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not_starts_with":
			var err error
			it.DescriptionNotStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_ends_with":
			var err error
			it.DescriptionEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description_not_ends_with":
			var err error
			it.DescriptionNotEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not":
			var err error
			it.NameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_in":
			var err error
			it.NameIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_in":
			var err error
			it.NameNotIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_lt":
			var err error
			it.NameLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_lte":
			var err error
			it.NameLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_gt":
			var err error
			it.NameGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_gte":
			var err error
			it.NameGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_contains":
			var err error
			it.NameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_contains":
			var err error
			it.NameNotContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_starts_with":
			var err error
			it.NameStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_starts_with":
			var err error
			it.NameNotStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_ends_with":
			var err error
			it.NameEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_ends_with":
			var err error
			it.NameNotEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "league":
			var err error
			it.League, err = ec.unmarshalOLeagueWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "users_every":
			var err error
			it.UsersEvery, err = ec.unmarshalOUserWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "users_some":
			var err error
			it.UsersSome, err = ec.unmarshalOUserWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "users_none":
			var err error
			it.UsersNone, err = ec.unmarshalOUserWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "owner":
			var err error
			it.Owner, err = ec.unmarshalOUserWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOTeamWhereInput2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOTeamWhereInput2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOTeamWhereInput2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTeamWhereUniqueInput(ctx context.Context, obj interface{}) (prisma.TeamWhereUniqueInput, error) {
	var it prisma.TeamWhereUniqueInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserCreateInput(ctx context.Context, obj interface{}) (UserCreateInput, error) {
	var it UserCreateInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sub":
			var err error
			it.Sub, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "picture":
			var err error
			it.Picture, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserWhereInput(ctx context.Context, obj interface{}) (prisma.UserWhereInput, error) {
	var it prisma.UserWhereInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not":
			var err error
			it.IDNot, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_in":
			var err error
			it.IDIn, err = ec.unmarshalOID2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_in":
			var err error
			it.IDNotIn, err = ec.unmarshalOID2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lt":
			var err error
			it.IDLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lte":
			var err error
			it.IDLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gt":
			var err error
			it.IDGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gte":
			var err error
			it.IDGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_contains":
			var err error
			it.IDContains, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_contains":
			var err error
			it.IDNotContains, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_starts_with":
			var err error
			it.IDStartsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_starts_with":
			var err error
			it.IDNotStartsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_ends_with":
			var err error
			it.IDEndsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_ends_with":
			var err error
			it.IDNotEndsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error
			it.CreatedAt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_not":
			var err error
			it.CreatedAtNot, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_in":
			var err error
			it.CreatedAtIn, err = ec.unmarshalODateTime2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_not_in":
			var err error
			it.CreatedAtNotIn, err = ec.unmarshalODateTime2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_lt":
			var err error
			it.CreatedAtLt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_lte":
			var err error
			it.CreatedAtLte, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_gt":
			var err error
			it.CreatedAtGt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_gte":
			var err error
			it.CreatedAtGte, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not":
			var err error
			it.NameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_in":
			var err error
			it.NameIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_in":
			var err error
			it.NameNotIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_lt":
			var err error
			it.NameLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_lte":
			var err error
			it.NameLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_gt":
			var err error
			it.NameGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_gte":
			var err error
			it.NameGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_contains":
			var err error
			it.NameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_contains":
			var err error
			it.NameNotContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_starts_with":
			var err error
			it.NameStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_starts_with":
			var err error
			it.NameNotStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_ends_with":
			var err error
			it.NameEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_ends_with":
			var err error
			it.NameNotEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sub":
			var err error
			it.Sub, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sub_not":
			var err error
			it.SubNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sub_in":
			var err error
			it.SubIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sub_not_in":
			var err error
			it.SubNotIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sub_lt":
			var err error
			it.SubLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sub_lte":
			var err error
			it.SubLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sub_gt":
			var err error
			it.SubGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sub_gte":
			var err error
			it.SubGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sub_contains":
			var err error
			it.SubContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sub_not_contains":
			var err error
			it.SubNotContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sub_starts_with":
			var err error
			it.SubStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sub_not_starts_with":
			var err error
			it.SubNotStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sub_ends_with":
			var err error
			it.SubEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sub_not_ends_with":
			var err error
			it.SubNotEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "picture":
			var err error
			it.Picture, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "picture_not":
			var err error
			it.PictureNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "picture_in":
			var err error
			it.PictureIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "picture_not_in":
			var err error
			it.PictureNotIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "picture_lt":
			var err error
			it.PictureLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "picture_lte":
			var err error
			it.PictureLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "picture_gt":
			var err error
			it.PictureGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "picture_gte":
			var err error
			it.PictureGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "picture_contains":
			var err error
			it.PictureContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "picture_not_contains":
			var err error
			it.PictureNotContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "picture_starts_with":
			var err error
			it.PictureStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "picture_not_starts_with":
			var err error
			it.PictureNotStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "picture_ends_with":
			var err error
			it.PictureEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "picture_not_ends_with":
			var err error
			it.PictureNotEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "points":
			var err error
			it.Points, err = ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "points_not":
			var err error
			it.PointsNot, err = ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "points_in":
			var err error
			it.PointsIn, err = ec.unmarshalOInt2ᚕint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "points_not_in":
			var err error
			it.PointsNotIn, err = ec.unmarshalOInt2ᚕint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "points_lt":
			var err error
			it.PointsLt, err = ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "points_lte":
			var err error
			it.PointsLte, err = ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "points_gt":
			var err error
			it.PointsGt, err = ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "points_gte":
			var err error
			it.PointsGte, err = ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
		case "teams_every":
			var err error
			it.TeamsEvery, err = ec.unmarshalOTeamWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "teams_some":
			var err error
			it.TeamsSome, err = ec.unmarshalOTeamWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "teams_none":
			var err error
			it.TeamsNone, err = ec.unmarshalOTeamWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "leagues_every":
			var err error
			it.LeaguesEvery, err = ec.unmarshalOLeagueWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "leagues_some":
			var err error
			it.LeaguesSome, err = ec.unmarshalOLeagueWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "leagues_none":
			var err error
			it.LeaguesNone, err = ec.unmarshalOLeagueWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "ownedTeams_every":
			var err error
			it.OwnedTeamsEvery, err = ec.unmarshalOTeamWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "ownedTeams_some":
			var err error
			it.OwnedTeamsSome, err = ec.unmarshalOTeamWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "ownedTeams_none":
			var err error
			it.OwnedTeamsNone, err = ec.unmarshalOTeamWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "ownedLeagues_every":
			var err error
			it.OwnedLeaguesEvery, err = ec.unmarshalOLeagueWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "ownedLeagues_some":
			var err error
			it.OwnedLeaguesSome, err = ec.unmarshalOLeagueWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "ownedLeagues_none":
			var err error
			it.OwnedLeaguesNone, err = ec.unmarshalOLeagueWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "matches_every":
			var err error
			it.MatchesEvery, err = ec.unmarshalOMatchWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatchWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "matches_some":
			var err error
			it.MatchesSome, err = ec.unmarshalOMatchWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatchWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "matches_none":
			var err error
			it.MatchesNone, err = ec.unmarshalOMatchWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatchWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOUserWhereInput2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOUserWhereInput2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOUserWhereInput2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserWhereUniqueInput(ctx context.Context, obj interface{}) (prisma.UserWhereUniqueInput, error) {
	var it prisma.UserWhereUniqueInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sub":
			var err error
			it.Sub, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var leagueImplementors = []string{"League"}

func (ec *executionContext) _League(ctx context.Context, sel ast.SelectionSet, obj *prisma.League) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, leagueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("League")
		case "id":
			out.Values[i] = ec._League_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._League_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":
			out.Values[i] = ec._League_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":
			out.Values[i] = ec._League_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "teams":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._League_teams(ctx, field, obj)
				return res
			})
		case "users":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._League_users(ctx, field, obj)
				return res
			})
		case "owner":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._League_owner(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var matchImplementors = []string{"Match"}

func (ec *executionContext) _Match(ctx context.Context, sel ast.SelectionSet, obj *prisma.Match) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, matchImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Match")
		case "id":
			out.Values[i] = ec._Match_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Match_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "plannedAt":
			out.Values[i] = ec._Match_plannedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "isRanked":
			out.Values[i] = ec._Match_isRanked(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "isFinished":
			out.Values[i] = ec._Match_isFinished(ctx, field, obj)
		case "league":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Match_league(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "user1":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Match_user1(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "user1points":
			out.Values[i] = ec._Match_user1points(ctx, field, obj)
		case "user2":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Match_user2(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "user2points":
			out.Values[i] = ec._Match_user2points(ctx, field, obj)
		case "winner":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Match_winner(ctx, field, obj)
				return res
			})
		case "winnerPoints":
			out.Values[i] = ec._Match_winnerPoints(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, mutationImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createLeague":
			out.Values[i] = ec._Mutation_createLeague(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteLeague":
			out.Values[i] = ec._Mutation_deleteLeague(ctx, field)
		case "createTeam":
			out.Values[i] = ec._Mutation_createTeam(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteTeam":
			out.Values[i] = ec._Mutation_deleteTeam(ctx, field)
		case "loginOrRegisterUser":
			out.Values[i] = ec._Mutation_loginOrRegisterUser(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "addUserToTeam":
			out.Values[i] = ec._Mutation_addUserToTeam(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteUser":
			out.Values[i] = ec._Mutation_deleteUser(ctx, field)
		case "createMatch":
			out.Values[i] = ec._Mutation_createMatch(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "endMatch":
			out.Values[i] = ec._Mutation_endMatch(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteMatch":
			out.Values[i] = ec._Mutation_deleteMatch(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, queryImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "league":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_league(ctx, field)
				return res
			})
		case "leagues":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_leagues(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "team":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_team(ctx, field)
				return res
			})
		case "teams":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_teams(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "user":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_user(ctx, field)
				return res
			})
		case "users":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_users(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "match":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_match(ctx, field)
				return res
			})
		case "matches":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_matches(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var teamImplementors = []string{"Team"}

func (ec *executionContext) _Team(ctx context.Context, sel ast.SelectionSet, obj *prisma.Team) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, teamImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Team")
		case "id":
			out.Values[i] = ec._Team_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Team_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Team_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Team_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "league":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_league(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "points":
			out.Values[i] = ec._Team_points(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "users":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_users(ctx, field, obj)
				return res
			})
		case "owner":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_owner(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *prisma.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._User_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":
			out.Values[i] = ec._User_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "sub":
			out.Values[i] = ec._User_sub(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "picture":
			out.Values[i] = ec._User_picture(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "teams":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_teams(ctx, field, obj)
				return res
			})
		case "leagues":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_leagues(ctx, field, obj)
				return res
			})
		case "points":
			out.Values[i] = ec._User_points(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "ownedTeams":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_ownedTeams(ctx, field, obj)
				return res
			})
		case "ownedLeagues":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_ownedLeagues(ctx, field, obj)
				return res
			})
		case "matches":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_matches(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNDateTime2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNDateTime2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int32(ctx context.Context, v interface{}) (int32, error) {
	return graphql.UnmarshalInt32(v)
}

func (ec *executionContext) marshalNInt2int32(ctx context.Context, sel ast.SelectionSet, v int32) graphql.Marshaler {
	res := graphql.MarshalInt32(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNLeague2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeague(ctx context.Context, sel ast.SelectionSet, v prisma.League) graphql.Marshaler {
	return ec._League(ctx, sel, &v)
}

func (ec *executionContext) marshalNLeague2ᚕᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeague(ctx context.Context, sel ast.SelectionSet, v []*prisma.League) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOLeague2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeague(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNLeague2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeague(ctx context.Context, sel ast.SelectionSet, v *prisma.League) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._League(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLeagueCreateInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋgraphqlᚋgeneratedᚐLeagueCreateInput(ctx context.Context, v interface{}) (LeagueCreateInput, error) {
	return ec.unmarshalInputLeagueCreateInput(ctx, v)
}

func (ec *executionContext) unmarshalNLeagueWhereInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueWhereInput(ctx context.Context, v interface{}) (prisma.LeagueWhereInput, error) {
	return ec.unmarshalInputLeagueWhereInput(ctx, v)
}

func (ec *executionContext) unmarshalNLeagueWhereUniqueInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueWhereUniqueInput(ctx context.Context, v interface{}) (prisma.LeagueWhereUniqueInput, error) {
	return ec.unmarshalInputLeagueWhereUniqueInput(ctx, v)
}

func (ec *executionContext) unmarshalNLeagueWhereUniqueInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueWhereUniqueInput(ctx context.Context, v interface{}) (*prisma.LeagueWhereUniqueInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNLeagueWhereUniqueInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueWhereUniqueInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalNMatch2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatch(ctx context.Context, sel ast.SelectionSet, v prisma.Match) graphql.Marshaler {
	return ec._Match(ctx, sel, &v)
}

func (ec *executionContext) marshalNMatch2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatch(ctx context.Context, sel ast.SelectionSet, v []prisma.Match) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMatch2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNMatch2ᚕᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatch(ctx context.Context, sel ast.SelectionSet, v []*prisma.Match) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMatch2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNMatch2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatch(ctx context.Context, sel ast.SelectionSet, v *prisma.Match) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Match(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMatchCreateInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋgraphqlᚋgeneratedᚐMatchCreateInput(ctx context.Context, v interface{}) (MatchCreateInput, error) {
	return ec.unmarshalInputMatchCreateInput(ctx, v)
}

func (ec *executionContext) unmarshalNMatchEndInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋgraphqlᚋgeneratedᚐMatchEndInput(ctx context.Context, v interface{}) (MatchEndInput, error) {
	return ec.unmarshalInputMatchEndInput(ctx, v)
}

func (ec *executionContext) unmarshalNMatchWhereInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatchWhereInput(ctx context.Context, v interface{}) (prisma.MatchWhereInput, error) {
	return ec.unmarshalInputMatchWhereInput(ctx, v)
}

func (ec *executionContext) unmarshalNMatchWhereUniqueInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatchWhereUniqueInput(ctx context.Context, v interface{}) (prisma.MatchWhereUniqueInput, error) {
	return ec.unmarshalInputMatchWhereUniqueInput(ctx, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNTeam2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeam(ctx context.Context, sel ast.SelectionSet, v prisma.Team) graphql.Marshaler {
	return ec._Team(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeam2ᚕᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeam(ctx context.Context, sel ast.SelectionSet, v []*prisma.Team) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTeam2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeam(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNTeam2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeam(ctx context.Context, sel ast.SelectionSet, v *prisma.Team) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Team(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTeamCreateInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋgraphqlᚋgeneratedᚐTeamCreateInput(ctx context.Context, v interface{}) (TeamCreateInput, error) {
	return ec.unmarshalInputTeamCreateInput(ctx, v)
}

func (ec *executionContext) unmarshalNTeamWhereInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamWhereInput(ctx context.Context, v interface{}) (prisma.TeamWhereInput, error) {
	return ec.unmarshalInputTeamWhereInput(ctx, v)
}

func (ec *executionContext) unmarshalNTeamWhereUniqueInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamWhereUniqueInput(ctx context.Context, v interface{}) (prisma.TeamWhereUniqueInput, error) {
	return ec.unmarshalInputTeamWhereUniqueInput(ctx, v)
}

func (ec *executionContext) marshalNUser2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUser(ctx context.Context, sel ast.SelectionSet, v prisma.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2ᚕᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUser(ctx context.Context, sel ast.SelectionSet, v []*prisma.User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOUser2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNUser2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUser(ctx context.Context, sel ast.SelectionSet, v *prisma.User) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserCreateInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋgraphqlᚋgeneratedᚐUserCreateInput(ctx context.Context, v interface{}) (UserCreateInput, error) {
	return ec.unmarshalInputUserCreateInput(ctx, v)
}

func (ec *executionContext) unmarshalNUserWhereInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereInput(ctx context.Context, v interface{}) (prisma.UserWhereInput, error) {
	return ec.unmarshalInputUserWhereInput(ctx, v)
}

func (ec *executionContext) unmarshalNUserWhereUniqueInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereUniqueInput(ctx context.Context, v interface{}) (prisma.UserWhereUniqueInput, error) {
	return ec.unmarshalInputUserWhereUniqueInput(ctx, v)
}

func (ec *executionContext) unmarshalNUserWhereUniqueInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereUniqueInput(ctx context.Context, v interface{}) (*prisma.UserWhereUniqueInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNUserWhereUniqueInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereUniqueInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBoolean2bool(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOBoolean2bool(ctx, sel, *v)
}

func (ec *executionContext) unmarshalODateTime2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalODateTime2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalODateTime2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNDateTime2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalODateTime2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNDateTime2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalODateTime2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalODateTime2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalODateTime2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalODateTime2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalID(v)
}

func (ec *executionContext) unmarshalOID2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOID2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOID2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOID2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOID2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	return graphql.MarshalInt(v)
}

func (ec *executionContext) unmarshalOInt2int32(ctx context.Context, v interface{}) (int32, error) {
	return graphql.UnmarshalInt32(v)
}

func (ec *executionContext) marshalOInt2int32(ctx context.Context, sel ast.SelectionSet, v int32) graphql.Marshaler {
	return graphql.MarshalInt32(v)
}

func (ec *executionContext) unmarshalOInt2ᚕint32(ctx context.Context, v interface{}) ([]int32, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]int32, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNInt2int32(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2ᚕint32(ctx context.Context, sel ast.SelectionSet, v []int32) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int32(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOInt2int(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOInt2int(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOInt2ᚖint32(ctx context.Context, v interface{}) (*int32, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOInt2int32(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOInt2ᚖint32(ctx context.Context, sel ast.SelectionSet, v *int32) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOInt2int32(ctx, sel, *v)
}

func (ec *executionContext) marshalOLeague2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeague(ctx context.Context, sel ast.SelectionSet, v prisma.League) graphql.Marshaler {
	return ec._League(ctx, sel, &v)
}

func (ec *executionContext) marshalOLeague2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeague(ctx context.Context, sel ast.SelectionSet, v []prisma.League) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLeague2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeague(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOLeague2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeague(ctx context.Context, sel ast.SelectionSet, v *prisma.League) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._League(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLeagueOrderByInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueOrderByInput(ctx context.Context, v interface{}) (prisma.LeagueOrderByInput, error) {
	tmp, err := graphql.UnmarshalString(v)
	return prisma.LeagueOrderByInput(tmp), err
}

func (ec *executionContext) marshalOLeagueOrderByInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueOrderByInput(ctx context.Context, sel ast.SelectionSet, v prisma.LeagueOrderByInput) graphql.Marshaler {
	return graphql.MarshalString(string(v))
}

func (ec *executionContext) unmarshalOLeagueOrderByInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueOrderByInput(ctx context.Context, v interface{}) (*prisma.LeagueOrderByInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOLeagueOrderByInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueOrderByInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOLeagueOrderByInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueOrderByInput(ctx context.Context, sel ast.SelectionSet, v *prisma.LeagueOrderByInput) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOLeagueOrderByInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueOrderByInput(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOLeagueWhereInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueWhereInput(ctx context.Context, v interface{}) (prisma.LeagueWhereInput, error) {
	return ec.unmarshalInputLeagueWhereInput(ctx, v)
}

func (ec *executionContext) unmarshalOLeagueWhereInput2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueWhereInput(ctx context.Context, v interface{}) ([]prisma.LeagueWhereInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]prisma.LeagueWhereInput, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNLeagueWhereInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOLeagueWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueWhereInput(ctx context.Context, v interface{}) (*prisma.LeagueWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOLeagueWhereInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐLeagueWhereInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOMatch2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatch(ctx context.Context, sel ast.SelectionSet, v prisma.Match) graphql.Marshaler {
	return ec._Match(ctx, sel, &v)
}

func (ec *executionContext) marshalOMatch2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatch(ctx context.Context, sel ast.SelectionSet, v *prisma.Match) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Match(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMatchOrderByInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatchOrderByInput(ctx context.Context, v interface{}) (prisma.MatchOrderByInput, error) {
	tmp, err := graphql.UnmarshalString(v)
	return prisma.MatchOrderByInput(tmp), err
}

func (ec *executionContext) marshalOMatchOrderByInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatchOrderByInput(ctx context.Context, sel ast.SelectionSet, v prisma.MatchOrderByInput) graphql.Marshaler {
	return graphql.MarshalString(string(v))
}

func (ec *executionContext) unmarshalOMatchOrderByInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatchOrderByInput(ctx context.Context, v interface{}) (*prisma.MatchOrderByInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOMatchOrderByInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatchOrderByInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOMatchOrderByInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatchOrderByInput(ctx context.Context, sel ast.SelectionSet, v *prisma.MatchOrderByInput) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOMatchOrderByInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatchOrderByInput(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOMatchWhereInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatchWhereInput(ctx context.Context, v interface{}) (prisma.MatchWhereInput, error) {
	return ec.unmarshalInputMatchWhereInput(ctx, v)
}

func (ec *executionContext) unmarshalOMatchWhereInput2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatchWhereInput(ctx context.Context, v interface{}) ([]prisma.MatchWhereInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]prisma.MatchWhereInput, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNMatchWhereInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatchWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOMatchWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatchWhereInput(ctx context.Context, v interface{}) (*prisma.MatchWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOMatchWhereInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐMatchWhereInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOString2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOString2string(ctx, sel, *v)
}

func (ec *executionContext) marshalOTeam2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeam(ctx context.Context, sel ast.SelectionSet, v prisma.Team) graphql.Marshaler {
	return ec._Team(ctx, sel, &v)
}

func (ec *executionContext) marshalOTeam2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeam(ctx context.Context, sel ast.SelectionSet, v []prisma.Team) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTeam2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeam(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOTeam2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeam(ctx context.Context, sel ast.SelectionSet, v *prisma.Team) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Team(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTeamOrderByInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamOrderByInput(ctx context.Context, v interface{}) (prisma.TeamOrderByInput, error) {
	tmp, err := graphql.UnmarshalString(v)
	return prisma.TeamOrderByInput(tmp), err
}

func (ec *executionContext) marshalOTeamOrderByInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamOrderByInput(ctx context.Context, sel ast.SelectionSet, v prisma.TeamOrderByInput) graphql.Marshaler {
	return graphql.MarshalString(string(v))
}

func (ec *executionContext) unmarshalOTeamOrderByInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamOrderByInput(ctx context.Context, v interface{}) (*prisma.TeamOrderByInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOTeamOrderByInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamOrderByInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOTeamOrderByInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamOrderByInput(ctx context.Context, sel ast.SelectionSet, v *prisma.TeamOrderByInput) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOTeamOrderByInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamOrderByInput(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOTeamWhereInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamWhereInput(ctx context.Context, v interface{}) (prisma.TeamWhereInput, error) {
	return ec.unmarshalInputTeamWhereInput(ctx, v)
}

func (ec *executionContext) unmarshalOTeamWhereInput2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamWhereInput(ctx context.Context, v interface{}) ([]prisma.TeamWhereInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]prisma.TeamWhereInput, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNTeamWhereInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTeamWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamWhereInput(ctx context.Context, v interface{}) (*prisma.TeamWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOTeamWhereInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐTeamWhereInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOUser2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUser(ctx context.Context, sel ast.SelectionSet, v prisma.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalOUser2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUser(ctx context.Context, sel ast.SelectionSet, v []prisma.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOUser2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUser(ctx context.Context, sel ast.SelectionSet, v *prisma.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUserOrderByInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserOrderByInput(ctx context.Context, v interface{}) (prisma.UserOrderByInput, error) {
	tmp, err := graphql.UnmarshalString(v)
	return prisma.UserOrderByInput(tmp), err
}

func (ec *executionContext) marshalOUserOrderByInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserOrderByInput(ctx context.Context, sel ast.SelectionSet, v prisma.UserOrderByInput) graphql.Marshaler {
	return graphql.MarshalString(string(v))
}

func (ec *executionContext) unmarshalOUserOrderByInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserOrderByInput(ctx context.Context, v interface{}) (*prisma.UserOrderByInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOUserOrderByInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserOrderByInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOUserOrderByInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserOrderByInput(ctx context.Context, sel ast.SelectionSet, v *prisma.UserOrderByInput) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOUserOrderByInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserOrderByInput(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOUserWhereInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereInput(ctx context.Context, v interface{}) (prisma.UserWhereInput, error) {
	return ec.unmarshalInputUserWhereInput(ctx, v)
}

func (ec *executionContext) unmarshalOUserWhereInput2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereInput(ctx context.Context, v interface{}) ([]prisma.UserWhereInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]prisma.UserWhereInput, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNUserWhereInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUserWhereInput2ᚖgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereInput(ctx context.Context, v interface{}) (*prisma.UserWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOUserWhereInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOUserWhereUniqueInput2ᚕgithubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereUniqueInput(ctx context.Context, v interface{}) ([]prisma.UserWhereUniqueInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]prisma.UserWhereUniqueInput, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNUserWhereUniqueInput2githubᚗcomᚋpPrecelᚋBeerKongServerᚋpkgᚋprismaᚋgeneratedᚋprismaᚑclientᚐUserWhereUniqueInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v introspection.Schema) graphql.Marshaler {
	return ec.___Schema(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
